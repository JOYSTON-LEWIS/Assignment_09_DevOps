pipeline {
    agent any

    environment {
        // AWS & Infra Credentials
        JL_AWS_REGION_ID                = credentials('JL_AWS_REGION_ID')
        JL_AWS_OUTPUT_FORMAT            = 'json'
        JL_AS09_EC2_IP_ADDRESS          = credentials('JL_AS09_EC2_IP_ADDRESS')
        JL_EC2_SSH_PRIVATE_KEY          = credentials('JL_EC2_SSH_PRIVATE_KEY')

        // App & GitHub
        JL_AS09_S3_BACKUP_BUCKET_NAME   = credentials('JL_AS09_S3_BACKUP_BUCKET_NAME')
        JL_AS09_LAMBDA_ROLE_ARN         = credentials('JL_AS09_LAMBDA_ROLE_ARN')
        JL_AS09_MONGO_URI_WITH_DB_NAME  = credentials('JL_AS09_MONGO_URI_WITH_DB_NAME')
        JL_AS09_GITHUB_REPO_URL         = credentials('JL_AS09_GITHUB_REPO_URL')

        // ASG Variables
        JL_AS09_EC2_AMI_ID            = credentials('JL_AS09_EC2_AMI_ID')
        JL_AS09_EC2_SUBNET_ID         = credentials('JL_AS09_EC2_SUBNET_ID')
        JL_AS09_EC2_SECURITY_GROUP_ID = credentials('JL_AS09_EC2_SECURITY_GROUP_ID')
        JL_AWS_EC2_KEY_PAIR_NAME      = credentials('JL_AWS_EC2_KEY_PAIR_NAME')
        JL_AS09_EC2_INSTANCE_TYPE     = credentials('JL_AS09_EC2_INSTANCE_TYPE')

        // Env Variables
        JL_BACKEND_MS_01                    = 3001
        JL_BACKEND_MS_02                    = 3002
        JL_AS09_FRONTEND_BASE_DOMAIN_MS_01  = "hello.joydevlabs.com"
        JL_AS09_FRONTEND_BASE_DOMAIN_MS_02  = "profile.joydevlabs.com"

        JL_S3_BUCKET_NAME                   = "jl-joyston-assignment-nine-bucket"
        JL_MONGO_BACKUP_IMAGE_REPO_NAME     = "jl-assignment-nine-mongo-atlas-backup-image"
        JL_MONGO_BACKUP_LAMBDA_NAME         = "jl-assignment-nine-mongo-backup-fn"
        JL_PROFILE_SERVICE_DB_NAME          = "assignment_nine"
    }

    stages {


        stage('Step 1: Clone GitHub Repo on EC2') {
            steps {
                sshagent (credentials: ['JL_EC2_SSH_PRIVATE_KEY']) {
                    script {
                        def SSH_IP = env.JL_AS09_EC2_IP_ADDRESS
                        def GIT_REPO = env.JL_AS09_GITHUB_REPO_URL
                        def repoName = GIT_REPO.split('/').last().replace('.git', '')

                        sh """
                        ssh -o StrictHostKeyChecking=no ubuntu@${SSH_IP} << EOF
mkdir -p ~/assignment09 && cd ~/assignment09
rm -rf ${repoName}
git clone ${GIT_REPO}
echo "‚úÖ Repo cloned to ~/assignment09/${repoName}"
EOF
                        """
                    }
                }
            }
        }

        stage('Step 2: Verify Repo Folder Structure & Validate Tools') {
            steps {
                sshagent (credentials: ['JL_EC2_SSH_PRIVATE_KEY']) {
                    script {
                        def SSH_IP = env.JL_AS09_EC2_IP_ADDRESS
                        def GIT_REPO = env.JL_AS09_GITHUB_REPO_URL
                        def repoName = GIT_REPO.split('/').last().replace('.git', '')
                        def REMOTE_DIR = "~/assignment09/${repoName}"

                        sh """
ssh -o StrictHostKeyChecking=no ubuntu@${SSH_IP} << EOF
set -e
cd ${REMOTE_DIR}

echo "üìÅ Verifying project structure..."
if [ ! -d "frontend" ] || [ ! -d "backend/helloService" ] || [ ! -d "backend/profileService" ]; then
    echo "‚ùå ERROR: Required folders missing!"
    exit 1
fi

echo "‚úÖ Folder structure is valid: frontend/, backend/helloService/, backend/profileService/"

echo "üîç Running validations for installed tools..."

# Docker
docker --version
sudo systemctl is-active docker

# Containerd
containerd --version
sudo systemctl is-active containerd

# Kubernetes
kubectl version --client=true --output=yaml
minikube version
crictl --version

# CNI
ls /opt/cni/bin | wc -l
if [ ! -f /opt/cni/bin/bridge ]; then
  echo "‚ùå CNI plugin 'bridge' missing"
  exit 1
fi

# Helm
helm version
helm repo list || echo "‚ö†Ô∏è Helm may not be initialized"

# Python & boto3
python3 --version
pip3 --version
pip3 show boto3

# Kernel modules and sysctl
lsmod | grep br_netfilter
lsmod | grep overlay

sysctl net.bridge.bridge-nf-call-iptables
sysctl net.ipv4.ip_forward

# Docker group membership
groups ubuntu | grep -qw docker || { echo "‚ùå 'ubuntu' user not in docker group"; exit 1; }

# AWS CLI version check
aws --version

# AWS identity check (verifies credentials are configured)
aws sts get-caller-identity || echo "‚ùå AWS CLI is not configured correctly"

echo "‚úÖ Tool validation complete"
EOF
                        """
                    }
                }
            }
        }


stage('Step 3: Dockerize and Push to ECR') {
    steps {
        sshagent (credentials: ['JL_EC2_SSH_PRIVATE_KEY']) {
            script {
                def SSH_IP = env.JL_AS09_EC2_IP_ADDRESS
                def GIT_REPO = env.JL_AS09_GITHUB_REPO_URL
                def repoName = GIT_REPO.split('/').last().replace('.git', '')
                def REMOTE_DIR = "~/assignment09/${repoName}"
                def AWS_REGION = env.JL_AWS_REGION_ID

                sh """
                ssh -o StrictHostKeyChecking=no ubuntu@${SSH_IP} << 'EOF'
set -e
cd ${REMOTE_DIR}

echo "üßπ Removing old Docker images..."
docker rmi -f \$(docker images -q) || true

echo "üê≥ Creating Dockerfiles..."

# helloService
cat <<'EOT' > backend/helloService/Dockerfile
FROM node:20.9.0-alpine
WORKDIR /app
COPY . .
RUN npm install
EXPOSE 3001
CMD ["node", "index.js"]
EOT

# profileService
cat <<'EOT' > backend/profileService/Dockerfile
FROM node:20.9.0-alpine
WORKDIR /app
COPY . .
RUN npm install
EXPOSE 3002
CMD ["node", "index.js"]
EOT

# frontend
cat <<'EOT' > frontend/Dockerfile
FROM node:20.9.0-alpine
WORKDIR /app
COPY . .
RUN npm install
EXPOSE 3000
CMD ["npm", "start"]
EOT

echo "‚¨áÔ∏è Pulling base image..."
docker pull node:20.9.0-alpine

echo "üßπ Removing stale Docker credentials..."
rm -f ~/.docker/config.json || true

ACCOUNT_ID=\$(aws sts get-caller-identity --query Account --output text)
ECR_BASE="\${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

for SERVICE in hello-service profile-service frontend; do
  REPO_NAME="jl-assignment-nine-\$SERVICE"
  IMAGE_TAG="\$REPO_NAME"

  echo "üìÅ Checking/creating ECR repo: \$REPO_NAME"
  aws ecr describe-repositories --repository-names \$REPO_NAME || \
  aws ecr create-repository --repository-name \$REPO_NAME

  echo "üîê Logging into ECR..."
  aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin \$ECR_BASE

  echo "üì§ Building and pushing: \$SERVICE"

  if [ "\$SERVICE" = "frontend" ]; then
    cd frontend
  elif [ "\$SERVICE" = "hello-service" ]; then
    cd backend/helloService
  elif [ "\$SERVICE" = "profile-service" ]; then
    cd backend/profileService
  fi

  docker build -t \$IMAGE_TAG .
  docker tag \$IMAGE_TAG \$ECR_BASE/\$REPO_NAME
  docker push \$ECR_BASE/\$REPO_NAME
  cd - > /dev/null
done

echo "‚úÖ All images built and pushed to ECR successfully."
EOF
                """
            }
        }
    }
}


stage('Step 10.1: Generate Lambda Docker Files') {
  steps {
    sshagent (credentials: ['JL_EC2_SSH_PRIVATE_KEY']) {
      sh '''
        ssh -o StrictHostKeyChecking=no ubuntu@$JL_AS09_EC2_IP_ADDRESS << 'EOF'
echo "‚úÖ Connected to EC2"

rm -rf mongo_lambda_backup

mkdir -p ~/mongo_lambda_backup && cd ~/mongo_lambda_backup

cat > lambda_function.py << 'PYEOF'
import os
import subprocess
import datetime
import boto3

def lambda_handler(event, context=None):
    mongo_uri = event.get("MONGO_URI")
    s3_bucket = event.get("S3_BUCKET")
    db_name = event.get("DB_NAME")
    region = event.get("REGION")
    aws_access_key = event.get("AWS_ACCESS_KEY_ID")
    aws_secret_key = event.get("AWS_SECRET_ACCESS_KEY")

    timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    filename = f"mongodb_backup_{timestamp}.gz"
    s3_key = f"mongodb_backups/{filename}"

    os.environ["AWS_ACCESS_KEY_ID"] = aws_access_key
    os.environ["AWS_SECRET_ACCESS_KEY"] = aws_secret_key
    os.environ["AWS_DEFAULT_REGION"] = region

    dump_cmd = f"mongodump --uri=\\"{mongo_uri}\\" --archive={filename} --gzip"
    subprocess.run(dump_cmd, shell=True, check=True)

    s3 = boto3.client("s3", region_name=region)
    with open(filename, "rb") as f:
        s3.upload_fileobj(f, s3_bucket, s3_key)

    print(f"‚úÖ Backup uploaded to S3: {s3_key}")
    return {"status": "success", "s3_key": s3_key}
PYEOF

cat > Dockerfile << 'DOCKER'
FROM public.ecr.aws/lambda/python:3.11-slim

RUN pip install boto3 pymongo

COPY lambda_function.py ./

CMD [ "lambda_function.lambda_handler" ]
DOCKER

echo "‚úÖ Files created"
EOF
      '''
    }
  }
}


stage('Step 10.2: Ensure Mongo Backup ECR Repo Exists') {
    steps {
        script {
            withCredentials([[
                $class: 'AmazonWebServicesCredentialsBinding',
                credentialsId: 'JL_AWS_CREDENTIALS',
                accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
            ]]) {
                withEnv([
                    "JL_MONGO_BACKUP_IMAGE_REPO_NAME=${env.JL_MONGO_BACKUP_IMAGE_REPO_NAME}",
                    "JL_AWS_REGION=${env.JL_AWS_REGION_ID}"
                ]) {
                    sh '''
                    echo "üîç Checking if ECR repo exists..."
                    if ! aws ecr describe-repositories --region "$JL_AWS_REGION" --repository-names "$JL_MONGO_BACKUP_IMAGE_REPO_NAME" > /dev/null 2>&1; then
                        echo "üì¶ Creating ECR repo: $JL_MONGO_BACKUP_IMAGE_REPO_NAME"
                        aws ecr create-repository --repository-name "$JL_MONGO_BACKUP_IMAGE_REPO_NAME" --region "$JL_AWS_REGION"
                    else
                        echo "‚úÖ ECR repo already exists: $JL_MONGO_BACKUP_IMAGE_REPO_NAME"
                    fi
                    '''
                }
            }
        }
    }
}




stage('Step 10.3: Build and Push Mongo Backup Docker Image') {
    steps {
        script {
            withCredentials([[ 
                $class: 'AmazonWebServicesCredentialsBinding',
                credentialsId: 'JL_AWS_CREDENTIALS',
                accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
            ]]) {
                withEnv([
                    "JL_MONGO_BACKUP_IMAGE_REPO_NAME=${env.JL_MONGO_BACKUP_IMAGE_REPO_NAME}",
                    "JL_AWS_REGION=${env.JL_AWS_REGION_ID}"
                ]) {
                    sh '''                    
                    export DOCKER_BUILDKIT=0

                    echo "üìÑ Writing Dockerfile..."
cat > Dockerfile <<EOF
FROM public.ecr.aws/docker/library/python:3.11-slim

RUN apt-get update && \
    apt-get install -y gnupg curl && \
    curl -fsSL https://pgp.mongodb.com/server-6.0.asc | gpg --dearmor -o /usr/share/keyrings/mongodb-server-6.0.gpg && \
    echo "deb [ signed-by=/usr/share/keyrings/mongodb-server-6.0.gpg ] https://repo.mongodb.org/apt/debian bullseye/mongodb-org/6.0 main" | tee /etc/apt/sources.list.d/mongodb-org-6.0.list && \
    apt-get update && \
    apt-get install -y mongodb-database-tools && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

RUN pip install --no-cache-dir pymongo boto3

COPY backup_script.py /app/backup_script.py

CMD ["python", "/app/backup_script.py"]
EOF

                    echo "üìÑ Writing backup_script.py..."
cat > backup_script.py <<EOF
import os, boto3, subprocess, datetime

mongo_uri = os.getenv("MONGO_URI")
s3_bucket = os.getenv("S3_BUCKET")
backup_prefix = os.getenv("S3_PREFIX", "mongodb_backups")

timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
archive_name = f"backup_{timestamp}.gz"

subprocess.run([
    "mongodump",
    f"--uri={mongo_uri}",
    "--archive=" + archive_name,
    "--gzip"
], check=True)

s3 = boto3.client("s3")
s3.upload_file(archive_name, s3_bucket, f"{backup_prefix}/{archive_name}")
print("‚úÖ Backup uploaded to S3 as", f"{backup_prefix}/{archive_name}")
EOF

                    echo "üõ†Ô∏è Building MongoDB backup Docker image..."
                    docker build -t $JL_MONGO_BACKUP_IMAGE_REPO_NAME .

                    echo "üîë Logging into ECR..."
                    aws ecr get-login-password --region "$JL_AWS_REGION" | docker login --username AWS --password-stdin 975050024946.dkr.ecr."$JL_AWS_REGION".amazonaws.com

                    echo "üì§ Tagging and pushing to ECR..."
                    docker tag $JL_MONGO_BACKUP_IMAGE_REPO_NAME:latest 975050024946.dkr.ecr.$JL_AWS_REGION.amazonaws.com/$JL_MONGO_BACKUP_IMAGE_REPO_NAME:latest
                    docker push 975050024946.dkr.ecr.$JL_AWS_REGION.amazonaws.com/$JL_MONGO_BACKUP_IMAGE_REPO_NAME:latest
                    '''
                }
            }
        }
    }
}



stage('Step 10.4: Deploy MongoDB Backup Lambda Function') {
    steps {
        script {
            withCredentials([[ 
                $class: 'AmazonWebServicesCredentialsBinding', 
                credentialsId: 'JL_AWS_CREDENTIALS', 
                accessKeyVariable: 'AWS_ACCESS_KEY_ID', 
                secretKeyVariable: 'AWS_SECRET_ACCESS_KEY' 
            ]]) {
                withEnv([
                    "JL_AWS_REGION=${env.JL_AWS_REGION_ID}",
                    "JL_MONGO_BACKUP_LAMBDA_NAME=${env.JL_MONGO_BACKUP_LAMBDA_NAME}",
                    "JL_MONGO_BACKUP_IMAGE_REPO_NAME=${env.JL_MONGO_BACKUP_IMAGE_REPO_NAME}",
                    "JL_MONGO_ATLAS_URI=${env.JL_MONGO_ATLAS_URI}",
                    "JL_PROFILE_SERVICE_DB_NAME=${env.JL_PROFILE_SERVICE_DB_NAME}",
                    "JL_S3_BUCKET_NAME=${env.JL_S3_BUCKET_NAME}"
                ]) {
                    sh '''
                    echo "üöÄ Creating/Updating Lambda Function..."

                    ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text --region "$JL_AWS_REGION")
                    echo "üîç Using AWS Account ID: $ACCOUNT_ID"

                    echo "üîó Checking if Lambda function exists..."
                    if aws lambda get-function --function-name "$JL_MONGO_BACKUP_LAMBDA_NAME" --region "$JL_AWS_REGION" > /dev/null 2>&1; then
                        echo "üîÅ Updating existing Lambda..."
                        aws lambda update-function-code \
                          --function-name "$JL_MONGO_BACKUP_LAMBDA_NAME" \
                          --image-uri "$ACCOUNT_ID.dkr.ecr.$JL_AWS_REGION.amazonaws.com/$JL_MONGO_BACKUP_IMAGE_REPO_NAME:latest" \
                          --region "$JL_AWS_REGION"
                    else
                        echo "üÜï Creating new Lambda..."

                        ROLE_NAME="${JL_MONGO_BACKUP_LAMBDA_NAME}-execution-role"

                        echo "üìú Creating trust policy..."
                        TRUST_FILE=trust-policy.json
                        cat > $TRUST_FILE <<EOF
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
EOF

                        echo "üõ°Ô∏è Creating IAM role (if not exists)..."
                        if ! aws iam get-role --role-name "$ROLE_NAME" --region "$JL_AWS_REGION" > /dev/null 2>&1; then
                          aws iam create-role \
                            --role-name "$ROLE_NAME" \
                            --assume-role-policy-document file://$TRUST_FILE \
                            --region "$JL_AWS_REGION"

                          echo "üîê Attaching basic execution policy..."
                          aws iam attach-role-policy \
                            --role-name "$ROLE_NAME" \
                            --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole \
                            --region "$JL_AWS_REGION"

                          echo "üïê Waiting for IAM role propagation..."
                          sleep 10
                        else
                          echo "‚ÑπÔ∏è Role already exists. Skipping creation."
                        fi

                        echo "üöÄ Creating Lambda with ECR image..."
                        aws lambda create-function \
                          --function-name "$JL_MONGO_BACKUP_LAMBDA_NAME" \
                          --package-type Image \
                          --code ImageUri="$ACCOUNT_ID.dkr.ecr.$JL_AWS_REGION.amazonaws.com/$JL_MONGO_BACKUP_IMAGE_REPO_NAME:latest" \
                          --role "arn:aws:iam::$ACCOUNT_ID:role/$ROLE_NAME" \
                          --timeout 900 \
                          --memory-size 1024 \
                          --region "$JL_AWS_REGION" \
                          --environment Variables="{\"MONGO_URI\":\"$JL_MONGO_ATLAS_URI\",\"S3_BUCKET\":\"$JL_S3_BUCKET_NAME\",\"S3_PREFIX\":\"mongodb_backups\"}"

                        echo "‚úÖ Lambda function '$JL_MONGO_BACKUP_LAMBDA_NAME' created successfully."
                    fi

                    echo "üß™ Invoking Lambda function to test backup..."
                    aws lambda invoke \
                      --function-name "$JL_MONGO_BACKUP_LAMBDA_NAME" \
                      --region "$JL_AWS_REGION" \
                      /tmp/mongo-backup-output.json

                    echo "üìÑ Lambda output:"
                    cat /tmp/mongo-backup-output.json
                    '''
                }
            }
        }
    }
}











/*

stage('Step 6.1: Deploy Backend EC2s in ASG') {
            steps {
                sshagent (credentials: ['JL_EC2_SSH_PRIVATE_KEY']) {
                    script {
                        sh """
                        ssh -o StrictHostKeyChecking=no ubuntu@${SSH_IP} << 'EOF'
                        set -e
                        echo "üöÄ Creating Launch Template"
                        aws ec2 create-launch-template \
                        --launch-template-name JL-Assignment-Nine-LaunchTemplate \
                        --version-description "v1" \
                        --launch-template-data ' {
                            "ImageId": "${JL_AS09_EC2_AMI_ID}",
                            "InstanceType": "${JL_AS09_EC2_INSTANCE_TYPE}",
                            "KeyName": "${JL_AWS_EC2_KEY_PAIR_NAME}",
                            "SecurityGroupIds": ["${JL_AS09_EC2_SECURITY_GROUP_ID}"],
                            "UserData": "$(echo -n '#!/bin/bash\n\n# Install Docker\napt update -y && apt install -y docker.io\nsystemctl start docker && systemctl enable docker\n\n# Fetch AWS Account ID\nAWS_REGION=${AWS_DEFAULT_REGION}\nAWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)\nREGISTRY=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com\n\n# Authenticate with ECR\naws ecr get-login-password --region ${AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin ${REGISTRY}\n\n# Run helloService\ndocker pull ${REGISTRY}/jl-assignment-nine-hello-service\ndocker run -d --name helloService -p 3001:3001 \\\n  -e PORT=3001 \\\n  ${REGISTRY}/jl-assignment-nine-hello-service\n\n# Run profileService\ndocker pull ${REGISTRY}/jl-assignment-nine-profile-service\ndocker run -d --name profileService -p 3002:3002 \\\n  -e PORT=3002 \\\n  -e MONGO_URL=mongodb://localhost:27017/profiledb \\\n  ${REGISTRY}/jl-assignment-nine-profile-service' | base64)"
                        }'

                        echo "üõ†Ô∏è Creating Auto Scaling Group"
                        aws autoscaling create-auto-scaling-group \
                        --auto-scaling-group-name JL-Assignment-Nine-ASG \
                        --launch-template LaunchTemplateName=JL-Assignment-Nine-LaunchTemplate,Version=1 \
                        --min-size 2 --max-size 2 --desired-capacity 2 \
                        --vpc-zone-identifier "${JL_AS09_EC2_SUBNET_ID}"
                        """
                    }
                }
            }
        }

        stage('Step 7.1: Create ALB and Register Target Group') {
            steps {
                sshagent (credentials: ['JL_EC2_SSH_PRIVATE_KEY']) {
                    script {
                        sh """
                        ssh -o StrictHostKeyChecking=no ubuntu@${SSH_IP} << 'EOF'
                        set -e
                        echo "üåê Creating Target Group"
                        TG_ARN=$(aws elbv2 create-target-group \
                            --name jl-backend-tg \
                            --protocol HTTP \
                            --port 3001 \
                            --vpc-id $(aws ec2 describe-subnets --subnet-ids ${JL_AS09_EC2_SUBNET_ID} --query 'Subnets[0].VpcId' --output text) \
                            --target-type instance \
                            --query 'TargetGroups[0].TargetGroupArn' --output text)

                        echo "üöÄ Creating ALB"
                        ALB_ARN=$(aws elbv2 create-load-balancer \
                            --name jl-backend-alb \
                            --subnets ${JL_AS09_EC2_SUBNET_ID} \
                            --security-groups ${JL_AS09_EC2_SECURITY_GROUP_ID} \
                            --query 'LoadBalancers[0].LoadBalancerArn' --output text)

                        echo "üß† Creating Listener"
                        aws elbv2 create-listener \
                            --load-balancer-arn $ALB_ARN \
                            --protocol HTTP \
                            --port 80 \
                            --default-actions Type=forward,TargetGroupArn=$TG_ARN

                        echo "‚è≥ Waiting for instances to attach"
                        sleep 60

                        echo "üì¶ Registering instances to target group"
                        INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name JL-Assignment-Nine-ASG \
                            --query 'AutoScalingGroups[0].Instances[*].InstanceId' --output text)

                        for ID in $INSTANCE_IDS; do
                        aws elbv2 register-targets --target-group-arn $TG_ARN --targets Id=$ID,Port=3001
                        done

                        echo "üåê Getting ALB DNS"
                        aws elbv2 describe-load-balancers --names jl-backend-alb --query 'LoadBalancers[0].DNSName' --output text
                        """
                    }
                }
            }
        }

        stage('Step 9: Cleanup (Optional)') {
            steps {
                sshagent (credentials: ['JL_EC2_SSH_PRIVATE_KEY']) {
                    script {
                        sh """
                        ssh -o StrictHostKeyChecking=no ubuntu@${SSH_IP} << 'EOF'
                        set -e
                        echo "üßπ Deleting Auto Scaling Group"
                        aws autoscaling delete-auto-scaling-group \
                            --auto-scaling-group-name JL-Assignment-Nine-ASG --force-delete

                        echo "üßπ Deleting Launch Template"
                        aws ec2 delete-launch-template \
                            --launch-template-name JL-Assignment-Nine-LaunchTemplate

                        echo "üßπ Deleting Target Group"
                        TG_ARN=$(aws elbv2 describe-target-groups --names jl-backend-tg --query 'TargetGroups[0].TargetGroupArn' --output text)
                        aws elbv2 delete-target-group --target-group-arn $TG_ARN

                        echo "üßπ Deleting Load Balancer"
                        ALB_ARN=$(aws elbv2 describe-load-balancers --names jl-backend-alb --query 'LoadBalancers[0].LoadBalancerArn' --output text)
                        aws elbv2 delete-load-balancer --load-balancer-arn $ALB_ARN
                        """
                    }
                }
            }
        }



stage('Step 3: Dockerize and Push to ECR') {
    steps {
        sshagent (credentials: ['JL_EC2_SSH_PRIVATE_KEY']) {
            script {
                def SSH_IP = env.JL_AS09_EC2_IP_ADDRESS
                def GIT_REPO = env.JL_AS09_GITHUB_REPO_URL
                def repoName = GIT_REPO.split('/').last().replace('.git', '')
                def REMOTE_DIR = "~/assignment09/${repoName}"
                def AWS_REGION = env.JL_AWS_REGION_ID

                sh """
                ssh -o StrictHostKeyChecking=no ubuntu@${SSH_IP} << 'EOF'
set -e
cd ${REMOTE_DIR}

echo "üßπ Removing old Docker images..."
docker rmi -f \$(docker images -q) || true

echo "üê≥ Creating Dockerfiles..."

# helloService
cat <<EOT > backend/helloService/Dockerfile
FROM node:20.9.0-alpine
WORKDIR /app
COPY . .
RUN npm install
EXPOSE 3001
CMD ["sh", "-c", "echo PORT=\\\$PORT > .env && node index.js"]
EOT

# profileService
cat <<EOT > backend/profileService/Dockerfile
FROM node:20.9.0-alpine
WORKDIR /app
COPY . .
RUN npm install
EXPOSE 3002
CMD ["sh", "-c", "echo PORT=\\\$PORT > .env && echo MONGO_URL=\\\$MONGO_URL >> .env && node index.js"]
EOT

# frontend with npm start (no build)
cat <<EOT > frontend/Dockerfile
FROM node:20.9.0-alpine
WORKDIR /app
COPY . .
RUN npm install
EXPOSE 3000
CMD ["sh", "-c", "echo REACT_APP_HELLO_BASE_URL=\\\$REACT_APP_HELLO_BASE_URL > .env && echo REACT_APP_PROFILE_BASE_URL=\\\$REACT_APP_PROFILE_BASE_URL >> .env && npm start"]
EOT

echo "‚¨áÔ∏è Pulling base image..."
docker pull node:20.9.0-alpine

echo "üßπ Removing stale Docker credentials..."
rm -f ~/.docker/config.json || true

ACCOUNT_ID=\$(aws sts get-caller-identity --query Account --output text)
ECR_BASE="\${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

for SERVICE in hello-service profile-service frontend; do
  REPO_NAME="jl-assignment-nine-\$SERVICE"
  IMAGE_TAG="\$REPO_NAME"

  echo "üìÅ Checking/creating ECR repo: \$REPO_NAME"
  aws ecr describe-repositories --repository-names \$REPO_NAME || \
  aws ecr create-repository --repository-name \$REPO_NAME

  echo "üîê Logging into ECR..."
  aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin \$ECR_BASE

  echo "üì§ Building and pushing: \$SERVICE"

  if [ "\$SERVICE" = "frontend" ]; then
    cd frontend
  elif [ "\$SERVICE" = "hello-service" ]; then
    cd backend/helloService
  elif [ "\$SERVICE" = "profile-service" ]; then
    cd backend/profileService
  fi

  docker build -t \$IMAGE_TAG .
  docker tag \$IMAGE_TAG \$ECR_BASE/\$REPO_NAME
  docker push \$ECR_BASE/\$REPO_NAME
  cd - > /dev/null
done

echo "‚úÖ All images built and pushed to ECR successfully."
EOF
                """
            }
        }
    }
}

stage('Step 4: Deploy helloService via ASG') {
  steps {
    withCredentials([
      string(credentialsId: 'JL_AWS_REGION_ID', variable: 'JL_AWS_REGION_ID'),
      string(credentialsId: 'JL_AS09_EC2_AMI_ID', variable: 'JL_AS09_EC2_AMI_ID'),
      string(credentialsId: 'JL_AS09_EC2_INSTANCE_TYPE', variable: 'JL_AS09_EC2_INSTANCE_TYPE'),
      string(credentialsId: 'JL_AS09_EC2_SUBNET_ID', variable: 'JL_AS09_EC2_SUBNET_ID'),
      string(credentialsId: 'JL_AS09_EC2_SECURITY_GROUP_ID', variable: 'JL_AS09_EC2_SECURITY_GROUP_ID'),
      string(credentialsId: 'JL_AWS_EC2_KEY_PAIR_NAME', variable: 'JL_AWS_EC2_KEY_PAIR_NAME'),
      string(credentialsId: 'JL_AWS_EC2_KEY_PAIR_NAME', variable: 'JL_AWS_EC2_KEY_PAIR_NAME')
    ]) {
      sh '''
        echo "üöÄ Creating Launch Template & ASG for helloService..."

        cat <<EOF > create_hello_asg.py
import boto3
import time
import base64
import os

region = os.environ['JL_AWS_REGION_ID']
ami_id = os.environ['JL_AS09_EC2_AMI_ID']
instance_type = os.environ['JL_AS09_EC2_INSTANCE_TYPE']
subnet_id = os.environ['JL_AS09_EC2_SUBNET_ID']
security_group_id = os.environ['JL_AS09_EC2_SECURITY_GROUP_ID']
key_pair = os.environ['JL_AWS_EC2_KEY_PAIR_NAME']

ec2 = boto3.client('ec2', region_name=region)
autoscaling = boto3.client('autoscaling', region_name=region)

aws_account_id = boto3.client('sts').get_caller_identity()['Account']
ecr_uri = f"{aws_account_id}.dkr.ecr.{region}.amazonaws.com/jl-assignment-nine-hello-service"

user_data_script = f"""#!/bin/bash
sudo apt update -y
sudo apt install -y docker.io
sudo systemctl start docker
sudo systemctl enable docker

aws ecr get-login-password --region {region} | docker login --username AWS --password-stdin {aws_account_id}.dkr.ecr.{region}.amazonaws.com

docker pull {ecr_uri}
docker run -d --name helloService -p 3001:3001 -e PORT=3001 {ecr_uri}
"""

encoded_user_data = base64.b64encode(user_data_script.encode()).decode()

lt_name = 'JL-Assignment9-helloService-LT'
asg_name = 'JL-Assignment9-helloService-ASG'

print(f"‚úÖ Creating Launch Template: {lt_name}")
lt = ec2.create_launch_template(
    LaunchTemplateName=lt_name,
    LaunchTemplateData={
        'ImageId': ami_id,
        'InstanceType': instance_type,
        'KeyName': key_pair,
        'SecurityGroupIds': [security_group_id],
        'UserData': encoded_user_data
    }
)

lt_id = lt['LaunchTemplate']['LaunchTemplateId']

print(f"‚úÖ Creating Auto Scaling Group: {asg_name}")
autoscaling.create_auto_scaling_group(
    AutoScalingGroupName=asg_name,
    LaunchTemplate={
        'LaunchTemplateId': lt_id,
        'Version': '$Latest'
    },
    MinSize=1,
    MaxSize=1,
    DesiredCapacity=1,
    VPCZoneIdentifier=subnet_id,
    Tags=[
        {
            'ResourceId': asg_name,
            'ResourceType': 'auto-scaling-group',
            'Key': 'Name',
            'Value': 'JL-helloService-instance',
            'PropagateAtLaunch': True
        }
    ]
)

print("üéâ ASG and Launch Template for helloService created successfully.")
EOF

        python3 create_hello_asg.py
      '''
    }
  }
}
*/



/*
stage('Step 4.1: Deploy helloService via ASG') {
    steps {
        sshagent (credentials: ['JL_EC2_SSH_PRIVATE_KEY']) {
            script {
                def ip = env.JL_AS09_EC2_IP_ADDRESS

                sh """
ssh -o StrictHostKeyChecking=no ubuntu@${ip} << 'EOF'
echo "üöÄ Deploying helloService"

AWS_ACCOUNT_ID=\$(aws sts get-caller-identity --query Account --output text)
AWS_REGION=\$(aws configure get region)
REGISTRY="\${AWS_ACCOUNT_ID}.dkr.ecr.\${AWS_REGION}.amazonaws.com"
IMAGE="\${REGISTRY}/jl-assignment-nine-hello-service"

sudo docker stop helloService || true && sudo docker rm helloService || true
aws ecr get-login-password --region \${AWS_REGION} | sudo docker login --username AWS --password-stdin \${REGISTRY}
sudo docker pull \${IMAGE}
sudo docker run -d --name helloService -p 3001:3001 \${IMAGE}
EOF
                """
            }
        }
    }
}

stage('Step 4.2: Deploy profileService via ASG') {
    steps {
        sshagent (credentials: ['JL_EC2_SSH_PRIVATE_KEY']) {
            script {
                def ip = env.JL_AS09_EC2_IP_ADDRESS

                sh """
ssh -o StrictHostKeyChecking=no ubuntu@${ip} << 'EOF'
echo "üöÄ Deploying profileService"

AWS_ACCOUNT_ID=\$(aws sts get-caller-identity --query Account --output text)
AWS_REGION=\$(aws configure get region)
REGISTRY="\${AWS_ACCOUNT_ID}.dkr.ecr.\${AWS_REGION}.amazonaws.com"
IMAGE="\${REGISTRY}/jl-assignment-nine-profile-service"

sudo docker stop profileService || true && sudo docker rm profileService || true
aws ecr get-login-password --region \${AWS_REGION} | sudo docker login --username AWS --password-stdin \${REGISTRY}
sudo docker pull \${IMAGE}
sudo docker run -d --name profileService -p 3002:3002 \${IMAGE}
EOF
                """
            }
        }
    }
}

stage('Step 4.3: Deploy frontend via ASG') {
    steps {
        sshagent (credentials: ['JL_EC2_SSH_PRIVATE_KEY']) {
            script {
                def ip = env.JL_AS09_EC2_IP_ADDRESS

                sh """
ssh -o StrictHostKeyChecking=no ubuntu@${ip} << 'EOF'
echo "üöÄ Deploying frontend"

AWS_ACCOUNT_ID=\$(aws sts get-caller-identity --query Account --output text)
AWS_REGION=\$(aws configure get region)
REGISTRY="\${AWS_ACCOUNT_ID}.dkr.ecr.\${AWS_REGION}.amazonaws.com"
IMAGE="\${REGISTRY}/jl-assignment-nine-frontend"

sudo docker stop frontend || true && sudo docker rm frontend || true
aws ecr get-login-password --region \${AWS_REGION} | sudo docker login --username AWS --password-stdin \${REGISTRY}
sudo docker pull \${IMAGE}
sudo docker run -d --name frontend -p 3000:3000 \${IMAGE}
EOF
                """
            }
        }
    }
}

stage('Step 4.4: Validate Endpoints') {
    steps {
        script {
            def ip = env.JL_AS09_EC2_IP_ADDRESS

            sh """
echo "üîç Validating Endpoints..."

curl -s --fail http://${ip}:3001/ | grep 'Hello World' && echo '‚úÖ helloService working' || echo '‚ùå helloService failed'

curl -s --fail http://${ip}:3002/fetchUser | grep 'success' && echo '‚úÖ profileService working' || echo '‚ùå profileService failed'
            """
        }
    }
}

*/





    }
}
